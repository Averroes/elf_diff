#!/usr/bin/python
  
# -*- coding: utf-8 -*-

# -*- mode: python -*-
#
# elf_diff
#
# Copyright (C) 2019  Noseglasses (shinynoseglasses@gmail.com)
#
# This program is free software: you can redistribute it and/or modify it under it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, version 3.
#
# This program is distributed in the hope that it will be useful, but WITHOUT but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with along with
# this program. If not, see <http://www.gnu.org/licenses/>.
#

import sys
import re
   
def fixStringForHTML(string):
   return string.replace("<", "&lt;").replace(">", "&gt;")
      
def generateSymbolTableEntry(symbol_name):
   return "<a name=\"table_%s\"><a href=\"#details_%s\">%s</a></a>" % \
          (symbol_name, symbol_name, symbol_name)

def generateSymbolTableEntryLight(symbol_name):
   return "<a href=\"#details_%s\">%s</a>" % \
          (symbol_name, symbol_name)

def generateSymbolDetailsTitle(symbol_name):
   return "<a name=\"details_%s\"><a href=\"#table_%s\">%s</a></a>" % \
          (symbol_name, symbol_name, tagSymbolName(symbol_name))

def generateSimilarSymbolTableEntry(similar_pair_id):
   return "<a name=\"similar_table_%s\"><a href=\"#similar_details_%s\">%s</a></a>" % \
          (similar_pair_id, similar_pair_id, similar_pair_id)
               
def generateSimilarSymbolDetailsTitle(similar_pair_id):
   return "<a name=\"similar_details_%s\"><a href=\"#similar_table_%s\">%s</a></a>" % \
          (similar_pair_id, similar_pair_id, similar_pair_id)
       
def tagSymbolName(symbol_name):
   return "<span class=\"symbol_name\">%s</span>" % (symbol_name)

def formatNumberHTML(number):
   return "<span class=\"number\">%s</span>" % (number)

def highlightNumberHTML(number):
   
   if number > 0:
      css_class = "deterioration"
   elif number < 0:
      css_class = "improvement"
   else:
      css_class = "unchanged"
      
   return "<span  class=\"%s number\">%+d</span>" % (css_class, number)

def memDeltaHTML(old_size, new_size):
   difference = new_size - old_size
   return highlightNumberHTML(new_size - old_size)
      
def tendencySymbol(from_size, to_size):
   if from_size > to_size:
      return "*"
   return ""
            
def formatMemChange(what, from_size, to_size):
   tendency_symbol = tendencySymbol(from_size, to_size)
   difference = to_size - from_size
   return "%s: %d -> %d bytes (%+d bytes) %s" % (what, from_size, to_size, difference, tendency_symbol)

def listUnion(l1, l2):
   return sorted(list(set(l1) & set(l2)))

symbol_type_class_method = 1
symbol_type_global_function = 2
symbol_type_class_data = 4
symbol_type_global_data = 3

class Settings(object):
   
   def __init__(self):
      
      import argparse

      parser = argparse.ArgumentParser(description='Compare elf binaries and list the differences in the disassembly.')
      parser.add_argument('--old', default = None, dest='old_binary_filename', help='The old elf binary')
      parser.add_argument('--new', default = None, dest='new_binary_filename', help='The new elf binary')
      parser.add_argument("binaries", nargs='*', default = None, help='The binaries (this is an alternative to --old and --new)')
      parser.add_argument('--old-alias', default = None, dest='old_alias', help='An alias string that is supposed to be used to reference the old binary')
      parser.add_argument('--new-alias', default = None, dest='new_alias', help='An alias string that is supposed to be used to reference the new binary')
      parser.add_argument('--old-info-file', default = None, dest='old_info_file', help='A text file with information about the old binary')
      parser.add_argument('--new-info-file', default = None, dest='new_info_file', help='A text file with information about the new binary')
      parser.add_argument('--build-info', default = "", dest='build_info', help='A string with build information')      
      parser.add_argument('--bin-dir', default='/usr/bin', dest='bin_dir', help='The place where the binaries live')
      parser.add_argument('--bin-prefix', default='', dest='bin_prefix', help='A prefix to be added to all binutils commands')
      parser.add_argument('--text-file', default=None, dest='text_file', help='A text file to write output to')
      parser.add_argument('--html-file', default=None, dest='html_file', help='A html file to write output to')
      parser.add_argument('--pdf-file', default=None, dest='pdf_file', help='A pdf file to write output to (details are skipped in pdf files)')
      parser.add_argument('--project-title', default=None, dest='project_title', help='A project title to use in reports')
      parser.add_argument('--driver-file', default=None, dest='driver_file', help='A file that contains driver information like binary filenames, etc.')
      
      actual_args = list()
      for arg_pos in range(1, len(sys.argv)):
         arg = sys.argv[arg_pos]
         if arg == "--":
               break
         actual_args.append(arg)
           
      args = parser.parse_args(actual_args)
      
      if len(args.binaries) == 0:
         if not args.old_binary_filename:
            print "No old binary filename defined"
            exit(1)
         else:
            self.old_binary_filename = args.old_binary_filename
            
         if not args.new_binary_filename:
            print "No new binary filename defined"
            exit(1)
         else:
            self.new_binary_filename = args.new_binary_filename
      elif len(args.binaries) == 2:
         if args.old_binary_filename:
            print "Old binary filename redundantly defined"
            exit(1)
         else:
            self.old_binary_filename = args.binaries[0]
            
         if args.new_binary_filename:
            print "Old binary filename redundantly defined"
            exit(1)
         else:
            self.new_binary_filename = args.binaries[1]
      else:
         print "Please specify either none or two binaries"
         exit(1)
      
      if args.old_alias:
         self.old_alias = args.old_alias
      else:
         self.old_alias = self.old_binary_filename
      
      if args.new_alias:
         self.new_alias = args.new_alias
      else:
         self.new_alias = self.new_binary_filename
         
      self.bin_dir = args.bin_dir
      self.bin_prefix = args.bin_prefix
      
      self.text_file = args.text_file
      self.html_file = args.html_file
      self.pdf_file = args.pdf_file
      
      self.objdump_command = self.bin_dir + "/" + self.bin_prefix + "objdump"
      self.nm_command = self.bin_dir + "/" + self.bin_prefix + "nm"
      self.size_command = self.bin_dir + "/" + self.bin_prefix + "size"
      
      self.project_title = args.project_title
      
      self.old_info_file = args.old_info_file
      self.new_info_file = args.new_info_file
      
      self.build_info = args.build_info
      
      self.driver_file = args.driver_file
      
      self.symbolsHTMLHeader = "H4"
      
      self.validate()
      
   def validate(self):

      import os.path
      import sys
      
      if not os.path.isfile(self.old_binary_filename):
         print "Old binary \'%s\' is not a file or cannot be found" % (self.old_binary_filename)
         sys.exit(1)
         
      if not os.path.isfile(self.new_binary_filename):
         print "New binary \'%s\' is not a file or cannot be found" % (self.new_binary_filename)
         sys.exit(1)
         
      if (not os.path.isfile(self.objdump_command)) or (not os.access(self.objdump_command, os.X_OK)):
         print "objdump command \'%s\' is either not a file or not executable" % (self.objdump_command)
         sys.exit(1)
         
      if (not os.path.isfile(self.nm_command)) or (not os.access(self.nm_command, os.X_OK)):
         print "nm command \'%s\' is either not a file or not executable" % (self.nm_command)
         sys.exit(1)
               
      if (not os.path.isfile(self.size_command)) or (not os.access(self.size_command, os.X_OK)):
         print "size command \'%s\' is either not a file or not executable" % (self.size_command)
         sys.exit(1)
         
      if self.old_info_file:
         if os.path.isfile(self.old_info_file):
            with open(self.old_info_file, "r") as f:
               self.old_binary_info = f.read()
         else:
            print "Unable to find old info file \'%s\'" % (self.old_info_file)
            sys.exit(1)
      else:
         self.old_binary_info = "<none>"
         
      if self.new_info_file:
         if os.path.isfile(self.new_info_file):
            with open(self.new_info_file, "r") as f:
               self.new_binary_info = f.read()
         else:
            print "Unable to find new info file \'%s\'" % (self.new_info_file)
            sys.exit(1)
      else:
         self.new_binary_info = "<none>"     
         
class Symbol(object):
   
   def __init__(self, name):
      self.name = name
      self.instruction_lines = []
      self.size = 0
      self.type = "?"
      
   def addInstuctions(self, instruction_line):
      self.instruction_lines.append(instruction_line)
      
   def __eq__(self, other):
      if not self.name == other.name:
         #print "Symbol name differs"
         return False
      
      if not self.size == other.size:
         return False
      
      if not len(self.instruction_lines) == len(other.instruction_lines):
         #print "Instructions differ"
         return False
      
      symbol_diff = [i for i, j in zip(self.instruction_lines, other.instruction_lines) if i != j]
      if len(symbol_diff) > 0:
         #print "Symbols differ"
         return False
      
      #print "Symbols equal"
      return True
   
   def getDifferencesAsString(self, other, indent):
      
      import difflib
      #from difflib_data import *

      diff = difflib.ndiff(self.instruction_lines, other.instruction_lines)
      #print list(diff)
      return indent + ("\n" + indent).join(list(diff))
   
   def getDifferencesAsHTML(self, other, indent):
   
      import difflib
      diff_class = difflib.HtmlDiff(tabsize=3, wrapcolumn=80)
      
      return diff_class.make_table(self.instruction_lines, \
                                   other.instruction_lines, \
                                   fromdesc='Old', \
                                   todesc='New', \
                                   context=True, \
                                   numlines=1000)
   
   def getInstructionsBlock(self, indent):
      return indent + ("\n" + indent).join(self.instruction_lines)
   
   def livesInProgramMemory(self):
      return (self.type != 'B') and (self.type != 'b') and \
             (self.type != 'S') and (self.type != 's')
      
   def parseSignature(self):
      
      symbol_regex = "((([\w:]*)?::)?([\w]+)::)?(\w+)(\((.*)\))?"
      match = re.match(symbol_regex, self.name)
      if match:
         self.namespace = match.group(3)
         self.klass = match.group(4)
         self.actual_name = match.group(5)
         self.parameters = match.group(7)
         self.symbol_parse_success = True
      else:
         self.actual_name = self.name
         self.symbol_parse_success = False
         return
         
      if self.klass:
         if self.parameters:
            self.symbol_type = symbol_type_class_method
         else:
            self.symbol_type = symbol_type_class_data
      else:
         if self.parameters:
            self.symbol_type = symbol_type_global_function
         else:
            self.symbol_type = symbol_type_global_data
         
   def init(self):
      self.parseSignature()
      
   def isMethodRenamedInClass(self, other):
      return self.namespace == other.namespace \
         and self.klass == other.klass \
         and self.parameters == other.parameters
   
   def isMethodSignatureChangedInClass(self, other):
      return self.namespace == other.namespace \
         and self.klass == other.klass \
         and self.actual_name == other.actual_name
   
   def doActualNameAndSignatureMatch(self, other):
      return self.actual_name == other.actual_name \
         and self.parameters == other.parameters
   
   def isClassRenamed(self, other):
      return self.doActualNameAndSignatureMatch(other)
         
   def isSimilar(self, other):
      
      if not (self.symbol_parse_success and other.symbol_parse_success):
         return False
      
      # Similarities
      #
      # Within the symbol_types
      #
      # symbol_type_class_method <-> symbol_type_global_function
      # symbol_type_class_data <-> symbol_type_global_data
      
      if self.symbol_type == symbol_type_class_method:
         if other.symbol_type == symbol_type_class_method:
            return self.isMethodRenamedInClass(other) \
                  or self.isMethodSignatureChangedInClass(other) \
                  or self.isClassRenamed(other)
               
         elif other.symbol_type == symbol_type_global_function:
            # Method moved to global?
            return self.actual_name == other.actual_name \
               and self.parameters == other.parameters
               
      elif self.symbol_type == symbol_type_global_function:
         if other.symbol_type == symbol_type_global_function:
            # Global function renamed?
            return self.actual_name == other.actual_name \
               and self.parameters == other.parameters
         
         elif other.symbol_type == symbol_type_class_method:
            # Function moved to class?
            return self.actual_name == other.actual_name \
               and self.parameters == other.parameters
      elif self.symbol_type == symbol_type_class_data:
         if other.symbol_type == symbol_type_class_data:
            # Class data renamed?
            return self.klass == other.klass \
               and self.namespace == other.namespace \
               and self.size == other.size
         elif other.symbol_type == symbol_type_global_data:
            # Datum moved from class to global?
            return self.actual_name == other.actual_name \
               and self.size == other.size
      elif self.symbol_type == symbol_type_global_data:
         if other.symbol_type == symbol_type_class_data:
            # Datum moved from global to class?
            return self.actual_name == other.actual_name \
               and self.size == other.size
         elif other.symbol_type == symbol_type_global_data:
            # compare namespace and size
            # Global symbol renamed?
            return self.namespace == other.namespace \
               and self.size == other.size
      
      return False
      
class Binary(object):
   
   def __init__(self, settings, filename):
      
      self.settings = settings
      self.filename = filename
      self.symbols = {}
      
      self.parseSymbols()
      
   def readObjdumpOutput(self):
      
      import subprocess
      
      cmd = [self.settings.objdump_command, '-drwCS', self.filename]
      proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

      o, e = proc.communicate()
      
      output = o.decode('ascii')
      #error = e.decode('ascii')
      
      return output
   
   def readNMOutput(self):
      
      import subprocess
      
      cmd = [self.settings.nm_command, '--print-size', '--size-sort', '--radix=d', '-C', self.filename]
      proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

      o, e = proc.communicate()
      
      output = o.decode('ascii')
      #error = e.decode('ascii')
      
      return output
   
   def readSizeOutput(self):
            
      import subprocess
      
      cmd = [self.settings.size_command, self.filename]
      proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

      o, e = proc.communicate()
      
      output = o.decode('ascii')
      #error = e.decode('ascii')
      
      return output
   
   def addSymbol(self, symbol):
      symbol.init()
      
      self.symbols[symbol.name] = symbol
   
   def parseSymbols(self):
      
      size_output = self.readSizeOutput()
      
      size_re = re.compile("^\s*([0-9]+)\s+([0-9]+)\s+([0-9]+)\s+([0-9]+)")
      for line in size_output.split("\n"):
         size_match = re.match(size_re, line)
         if size_match:
            self.text_size = int(size_match.group(1))
            self.data_size = int(size_match.group(2))
            self.bss_size = int(size_match.group(3))
            self.overall_size = int(size_match.group(4))
                               
            self.progmem_size = self.text_size + self.data_size
            self.static_ram_size = self.data_size + self.bss_size
            
            break
         
      objdump_output = self.readObjdumpOutput()
      
      #print "Output:"
      #print "%s" % (objdump_output)
      
      header_line_re = re.compile("^[0-9A-Fa-f]+ <(.+)>:")
      instruction_line_re = re.compile("^(\s*)[0-9A-Fa-f]+:\s+(.*)")
      #empty_line_re = re.compile("^\s*$")
                                  
      cur_symbol = None
      n_symbols = 0
      
      for line in objdump_output.split("\n"):
         
         header_match = re.match(header_line_re, line)
         if header_match:
            if cur_symbol:
               self.addSymbol(cur_symbol)
            cur_symbol = Symbol(header_match.group(1))
            n_symbols += 1
            #print "Found symbol %s" % (header_match.group(1))
         else:
            instruction_line_match = re.match(instruction_line_re, line)
            if instruction_line_match:
               #print "Found instruction line \'%s\'" % (instruction_line_match.group(1))
               cur_symbol.addInstuctions(instruction_line_match.group(1) + instruction_line_match.group(2))
            else:
               if cur_symbol:
                  cur_symbol.addInstuctions(line)

      if cur_symbol:
         self.addSymbol(cur_symbol)
      
      nm_output = self.readNMOutput()
      
      nm_regex = re.compile("^[0-9A-Fa-f]+\s([0-9A-Fa-f]+)\s(\w)\s(.+)")
      for line in nm_output.split("\n"):
         nm_match = re.match(nm_regex, line)
         
         if nm_match:
            symbol_size_str = nm_match.group(1)
            symbol_type = nm_match.group(2)
            symbol_name = nm_match.group(3)
            #print "Symbol %s: %d bytes" % (symbol_name, int(symbol_size_str))
            
            if not symbol_name in self.symbols.keys():
               data_symbol = Symbol(symbol_name)
               data_symbol.size = int(symbol_size_str)
               data_symbol.type = symbol_type
               self.addSymbol(data_symbol)
            else:
               self.symbols[symbol_name].size = int(symbol_size_str)
               self.symbols[symbol_name].type = symbol_type
         
   def __eq__(self, other):
      
      if len(self.symbols) != len(other.symbols):
         #print "Number of symbols differs"
         return False
      
      # Check if symbol names differ
      
      old_symbols = set(self.symbols.keys())
      new_symbols = set(other.symbols.keys())
      
      only_in_self = old_symbols - new_symbols
      if len(only_in_self) > 0:
         #print "Some symbols only in self"
         return False
      
      only_in_other = new_symbols - old_symbols
      if len(only_in_other) > 0:
         #print "Some symbols only in other"
         return False
      
      # Check if actual symbols differ
      
      for symbol_name in self.symbols.keys():
         
         old_symbol = self.symbols[symbol_name]
         new_symbol = other.symbols[symbol_name]
         
         if not (old_symbol == new_symbol):
            return False
         
      #print "Symbols identical"
         
      return True
   
   def __ne__(self, other):
      """Overrides the default implementation (unnecessary in Python 3)"""
      return not self.__eq__(other)
   
class Report(object):
   
   def generate():
      
      file_output_requested = False
            
      if self.settings.html_file:
         file_output_requested = True
         self.writeHTMLFile(self.settings.html_file, skip_details = False)

      if self.settings.text_file:
         file_output_requested = True
         self.settings.out = open(self.settings.text_file, "w")
         
      if self.settings.pdf_file:
         
         import tempfile
         
         tmp_html_file = tempfile._get_default_tempdir() + \
            "/" + next(tempfile._get_candidate_names()) + ".html"
         
         self.writeHTMLFile(tmp_html_file, skip_details = True)
         
         file_output_requested = True
         
         import pdfkit
         pdfkit.from_url(tmp_html_file, self.settings.pdf_file)
         
         import os
         os.remove(tmp_html_file)
               
      if not file_output_requested:
         import sys
         self.settings.out = sys.stdout
            
         self.writeTextFile()
         
   def configureHTMLTemplate(self, html_filename, keywords):
      
      import jinja2
      from jinja2 import Environment, FileSystemLoader, StrictUndefined
      
      env = Environment(loader=FileSystemLoader(repo_path), \
                                       undefined = StrictUndefined)
           
      #addGlobalJinjaFunction(GetComponentLink)
        
      try:
         creator = env.get_template("single_report_template.html")
         
      except jinja2.exceptions.TemplateError as e:
         print "Error creating jinja creator\n" + str(e)
         sys.exit(1)
         
      try:
         replacedContent = creator.render(keywords)
      except (jinja2.exceptions.TemplateError) as e:
         print "Error rendering jinja file \'" + \
            html_filename + "\'\n" + str(e)
         sys.exit(1)
      
      htmlFile = open(html_filename, 'w')
      
      htmlFile.write(replacedContent.encode('utf8'))
      
      htmlFile.close()
         
class BinaryPair(object):
            
   def __init__(self, settings, old_binary_filename, new_binary_filename):
      
      self.settings = settings
      
      self.old_binary_filename = old_binary_filename
      self.new_binary_filename = new_binary_filename
      
      self.old_binary = Binary(self.settings, self.old_binary_filename)
      self.new_binary = Binary(self.settings, self.new_binary_filename)
      
      self.prepareMeasures()
         
   def prepareMeasures(self):
      
      self.old_symbol_names = set(self.old_binary.symbols.keys())
      self.new_symbol_names = set(self.new_binary.symbols.keys())

      self.common_symbol_names = listUnion(self.old_symbol_names, self.new_symbol_names)
      self.symbols_only_in_old = sorted(self.old_symbol_names - self.new_symbol_names)
      self.symbols_only_in_new = sorted(self.new_symbol_names - self.old_symbol_names)
      
      self.similar_symbols = self.determineSimilarSymbols()
      
      self.computeNumSymbolsPersisting()
      self.computeNumSymbolsDisappeared()
      self.computeNumSymbolsNew()
      
      self.computeNumAssembliesDiffer()
      
   def determineSimilarSymbols(self):
      
      import operator
      
      symbol_pairs = []
      
      for old_symbol_name in self.symbols_only_in_old:
         old_symbol = self.old_binary.symbols[old_symbol_name]
         for new_symbol_name in self.symbols_only_in_new:
            new_symbol = self.new_binary.symbols[new_symbol_name]
      
            if old_symbol.isSimilar(new_symbol):
               symbol_pairs.append([old_symbol, new_symbol])
                                
                                
      # First sort symbol pairs by size difference
      #
      diff_by_symbol_pair = {}
      for i in range(0, len(symbol_pairs)):
         symbol_pair = symbol_pairs[i]
         
         old_symbol = symbol_pair[0]
         new_symbol = symbol_pair[1]
               
         difference = new_symbol.size - old_symbol.size
         
         diff_by_symbol_pair[i] = difference
         
      sorted_by_diff = sorted(diff_by_symbol_pair.items(), key=operator.itemgetter(1), reverse=True)  
      
      sorted_symbol_pairs = []
      for symbol_tuple in sorted_by_diff:
         index = symbol_tuple[0]
         sorted_symbol_pairs.append(symbol_pairs[index])
                                
      return sorted_symbol_pairs
   
   def computeNumSymbolsPersisting(self):
      
      self.num_symbol_size_changes = 0
      for symbol_name in self.common_symbol_names:
         old_symbol = self.old_binary.symbols[symbol_name]
         new_symbol = self.new_binary.symbols[symbol_name]
         if old_symbol.size != new_symbol.size:
            self.num_symbol_size_changes += 1
   
   def computeNumSymbolsDisappeared(self):
      self.num_bytes_disappeared = 0
      self.num_symbols_disappeared = len(self.symbols_only_in_old)
      for symbol_name in self.symbols_only_in_old:
         symbol = self.old_binary.symbols[symbol_name]
         self.num_bytes_disappeared += symbol.size
         
   def computeNumSymbolsNew(self):
      self.num_bytes_new = 0
      self.num_symbols_new = len(self.symbols_only_in_new)
      for symbol_name in self.symbols_only_in_new:
         symbol = self.new_binary.symbols[symbol_name]
         self.num_bytes_new += symbol.size
   
   def computeNumAssembliesDiffer(self):
      self.num_assemblies_differ = 0
      for symbol_name in self.common_symbol_names:
         old_symbol = self.old_binary.symbols[symbol_name]
         new_symbol = self.new_binary.symbols[symbol_name]
         
         if not old_symbol.__eq__(new_symbol):
            self.num_assemblies_differ += 1
      
class PairReport(Report):
   
   def __init__(self, settings, old_binary_filename, new_binary_filename):
      
      self.binary_pair = BinaryPair(settings, old_binary_filename, new_binary_filename)
   
   def generatePersistingSymbolsTableHTML(self):
      
      old_binary = self.binary_pair.old_binary
      new_binary = self.binary_pair.new_binary
      
      table_html = ""
      
      import operator
      
      diff_by_symbol = {}
      for symbol_name in self.binary_pair.common_symbol_names:
         old_symbol = old_binary.symbols[symbol_name]
         new_symbol = new_binary.symbols[symbol_name]
         
         difference = new_symbol.size - old_symbol.size
         
         diff_by_symbol[symbol_name] = difference
         
      sorted_by_diff = sorted(diff_by_symbol.items(), key=operator.itemgetter(1), reverse=True)   
      
      size_delta = 0
      
      for symbol_tuple in sorted_by_diff:
         
         symbol_name = symbol_tuple[0]
         
         old_symbol = old_binary.symbols[symbol_name]
         new_symbol = new_binary.symbols[symbol_name]
         
         if new_symbol.livesInProgramMemory():
            size_delta += new_symbol.size - old_symbol.size
         
         if old_symbol.size != new_symbol.size:
            symbol_name_html = fixStringForHTML(symbol_name)
            table_html += "<tr><td>%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td></tr>\n" % ( \
                              generateSymbolTableEntry(symbol_name_html), \
                              new_symbol.type, \
                              formatNumberHTML(old_symbol.size), \
                              formatNumberHTML(new_symbol.size), \
                              memDeltaHTML(old_symbol.size, new_symbol.size))
            
      return [table_html, highlightNumberHTML(size_delta)]
      
   def generateDisappearedSymbolsTableHTML(self):
      
      old_binary = self.binary_pair.old_binary
      
      table_html = ""
      overal_symbol_size = 0
      
      for symbol_name in sorted(self.binary_pair.symbols_only_in_old, \
                                key=lambda symbol_name: old_binary.symbols[symbol_name].size, \
                                reverse = True):
         symbol_name_html = fixStringForHTML(symbol_name)
         symbol = old_binary.symbols[symbol_name]
         table_html += "<tr><td>%s</td><td>%s</td><td>%s</td></tr>\n" % ( \
                              generateSymbolTableEntry(symbol_name_html), \
                              symbol.type, \
                              formatNumberHTML(symbol.size))
         
         if symbol.livesInProgramMemory():
            overal_symbol_size += symbol.size
            
      return [table_html, highlightNumberHTML(-overal_symbol_size)]  
   
   def generateNewSymbolsTableHTML(self):
      
      new_binary = self.binary_pair.new_binary
      
      table_html = ""
      overal_symbol_size = 0
      
      for symbol_name in sorted(self.binary_pair.symbols_only_in_new, \
                                key=lambda symbol_name: new_binary.symbols[symbol_name].size, \
                                reverse = True):
         symbol_name_html = fixStringForHTML(symbol_name)
         symbol = new_binary.symbols[symbol_name]
         table_html += "<tr><td>%s</td><td>%s</td><td>%s</td></tr>\n" % ( \
                              generateSymbolTableEntry(symbol_name_html), \
                              symbol.type, \
                              formatNumberHTML(symbol.size))
         
         if symbol.livesInProgramMemory():
            overal_symbol_size += symbol.size
            
      return [table_html, highlightNumberHTML(overal_symbol_size)]
      
   def generateSimilarSymbolsTableHTML(self):
           
      table_html = ""
      
      index = 0
      for symbol_pair in self.binary_pair.similar_symbols:
         
         index = index + 1
         
         old_symbol = symbol_pair[0]
         new_symbol = symbol_pair[1]
         
         old_symbol_name_html = fixStringForHTML(old_symbol.name)
         new_symbol_name_html = fixStringForHTML(new_symbol.name)
         
         table_html += "<tr><td>%s</td><td><p>%s</p><p>%s</p></td><td><p>%s</p><p>%s</p></td><td><p>%s</p><p>%s</p></td><td>%s</td></tr>\n" % ( \
                              generateSimilarSymbolTableEntry(str(index)), \
                              generateSymbolTableEntryLight(old_symbol_name_html), \
                              generateSymbolTableEntryLight(new_symbol_name_html), \
                              old_symbol.type, \
                              new_symbol.type, \
                              formatNumberHTML(old_symbol.size), \
                              formatNumberHTML(new_symbol.size), \
                              memDeltaHTML(old_symbol.size, new_symbol.size))
      
      return [table_html, len(self.binary_pair.similar_symbols)]
   
   def generatePersistentSymbolDetailsString(self):
      
      old_binary = self.binary_pair.old_binary
      new_binary = self.binary_pair.new_binary
      
      text = ""
      
      for symbol_name in self.binary_pair.common_symbol_names:
         
         old_symbol = old_binary.symbols[symbol_name]
         new_symbol = new_binary.symbols[symbol_name]
         
         if not old_symbol.__eq__(new_symbol):
            symbol_differences = old_symbol.getDifferencesAsString(new_symbol, "   ")
            if old_symbol.size == new_symbol.size:
               size_info = "size unchanged"
            else:
               size_info = formatMemChange("", old_symbol.size, new_symbol.size)
            text += "******************************************************************\n"
            text += "%s (%s)\n" % (symbol_name, size_info)
            text += "******************************************************************\n"
            text += "%s\n" % (symbol_differences)
            
      return text
   
   def generatePersistentSymbolDetailsHTML(self):
      
      old_binary = self.binary_pair.old_binary
      new_binary = self.binary_pair.new_binary
      
      html = ""
      
      for symbol_name in self.binary_pair.common_symbol_names:
         
         old_symbol = old_binary.symbols[symbol_name]
         new_symbol = new_binary.symbols[symbol_name]
         
         symbol_name_html = fixStringForHTML(symbol_name)
         
         if not old_symbol.__eq__(new_symbol):
            
            symbol_differences = old_symbol.getDifferencesAsHTML(new_symbol, "   ")
            
            if old_symbol.size == new_symbol.size:
               size_info = "size unchanged"
            else:
               size_info = formatMemChange("", old_symbol.size, new_symbol.size)
               
            html += "<%s>%s (%s)</%s>\n" % ( \
                                            self.settings.symbolsHTMLHeader, \
                                            generateSymbolDetailsTitle(symbol_name_html), \
                                            size_info, \
                                            self.settings.symbolsHTMLHeader)
            html += "%s\n" % (symbol_differences)
            
      return html
   
   def generateDisappearedSymbolDetailsString(self):
      
      text = ""
      
      if len(self.binary_pair.symbols_only_in_old) > 0:
         for symbol_name in self.binary_pair.symbols_only_in_old:
            symbol = self.binary_pair.old_binary.symbols[symbol_name]
            text += "******************************************************************\n"
            text += "%s: %d bytes\n" % (symbol_name, symbol.size)
            text += "******************************************************************\n"
            text += symbol.getInstructionsBlock("   ") + "\n"
            
      return text
   
   def generateDisappearedSymbolDetailsHTML(self):
      
      html = ""
      
      if len(self.binary_pair.symbols_only_in_old) > 0:
         html += "<pre>"
         for symbol_name in self.binary_pair.symbols_only_in_old:
            symbol = self.binary_pair.old_binary.symbols[symbol_name]
            symbol_name_html = fixStringForHTML(symbol_name)
            html += "<%s>%s: %d bytes</%s>\n" % ( \
                                                 self.settings.symbolsHTMLHeader, \
                                                 generateSymbolDetailsTitle(symbol_name_html), \
                                                 symbol.size, \
                                                 self.settings.symbolsHTMLHeader)
            html += fixStringForHTML(symbol.getInstructionsBlock("   ") + "\n")
         html += "</pre>"
            
      return html
   
   def generateNewSymbolDetailsString(self):
      
      text = ""
      
      if len(self.binary_pair.symbols_only_in_new) > 0:
         for symbol_name in self.binary_pair.symbols_only_in_new:
            symbol = self.binary_pair.new_binary.symbols[symbol_name]
            text += "******************************************************************\n"
            text += "%s: %d bytes\n" % (symbol_name, symbol.size)
            text += "******************************************************************\n"
            text += symbol.getInstructionsBlock("   ") + "\n"
            
      return text
      
   def generateNewSymbolDetailsHTML(self):
      
      html = ""
      
      if len(self.binary_pair.symbols_only_in_new) > 0:
         html += "<pre>"
         for symbol_name in self.symbols_only_in_new:
            symbol = self.binary_pair.new_binary.symbols[symbol_name]
            symbol_name_html = fixStringForHTML(symbol_name)
            html += "<%s>%s: %d bytes</%s>\n" % ( \
                                                 self.settings.symbolsHTMLHeader, \
                                                 generateSymbolDetailsTitle(symbol_name_html), \
                                                 symbol.size, \
                                                 self.settings.symbolsHTMLHeader)
            html += fixStringForHTML(symbol.getInstructionsBlock("   ") + "\n")
         html += "</pre>"
            
      return html
         
   def generateSimilarSymbolDetailsString(self):
      
      text = ""
      
      for symbol_pair in self.binary_pair.similar_symbols:
         
         old_symbol = symbol_pair[0]
         new_symbol = symbol_pair[1]
         
         symbol_differences = old_symbol.getDifferencesAsString(new_symbol, "   ")

         text += "******************************************************************\n"
         text += "%s (%s bytes)\n" % (old_symbol.name, old_symbol.size)
         text += "%s (%s bytes)\n" % (new_symbol.name, new_symbol.size)
         text += "******************************************************************\n"
         text += "%s\n" % (symbol_differences)
            
      return text
   
   def generateSimilarSymbolDetailsHTML(self):
      
      html = ""
      
      index = 0;
      for symbol_pair in self.binary_pair.similar_symbols:
         
         index = index + 1
         
         old_symbol = symbol_pair[0]
         new_symbol = symbol_pair[1]
         
         old_symbol_name_html = fixStringForHTML(old_symbol.name)
         new_symbol_name_html = fixStringForHTML(new_symbol.name)
            
         symbol_differences = old_symbol.getDifferencesAsHTML(new_symbol, "   ")
         
         if old_symbol.size == new_symbol.size:
            size_info = "size unchanged"
         else:
            size_info = formatMemChange("", old_symbol.size, new_symbol.size)
            
         html += "<%s>Similar pair %s (%s)</%s>\n" % ( \
                                          self.settings.symbolsHTMLHeader, \
                                          generateSimilarSymbolDetailsTitle(str(index)), \
                                          size_info, \
                                          self.settings.symbolsHTMLHeader)
         html += "<p>Old: %s</p>\n" % (generateSymbolDetailsTitle(old_symbol_name_html))
         html += "<p>New: %s</p>\n" % (generateSymbolDetailsTitle(new_symbol_name_html))
         html += "%s\n" % (symbol_differences)
            
      return html
   
   def writeHTMLFile(self, html_filename, skip_details):
      
      import os, inspect, datetime
      
      repo_path = os.path.dirname(os.path.realpath(inspect.getfile(inspect.currentframe())))
      
      old_binary = self.binary_pair.old_binary
      new_binary = self.binary_pair.new_binary
      
      #print "repo_path = " + repo_path
      
      # If we generate a pdf files, we skip the details
      #
      if skip_details:
         persisting_symbol_details_html = "skipped"
         disappeared_symbol_details_html = "skipped"
         new_symbol_details_html = "skipped"
         similar_symbol_details_html = "skipped"
      else:
         persisting_symbol_details_html = self.generatePersistentSymbolDetailsHTML()
         disappeared_symbol_details_html = self.generateDisappearedSymbolDetailsHTML()
         new_symbol_details_html = self.generateNewSymbolDetailsHTML()
         similar_symbol_details_html = self.generateSimilarSymbolDetailsHTML()
      
      if self.settings.project_title:
         doc_title = fixStringForHTML(self.settings.project_title)
      else:
         doc_title = "ELF Binary Comparison"
         
      [persisting_symbols_table, persisting_symbols_delta] = self.generatePersistingSymbolsTableHTML()
      [disappeared_symbols_table, disappeared_symbols_size] = self.generateDisappearedSymbolsTableHTML()
      [new_symbols_table, new_symbols_size] = self.generateNewSymbolsTableHTML()
      [similar_symbols_table, num_similar_symbols] = self.generateSimilarSymbolsTableHTML()
      
      keywords = {
          "page_title" : u"ELF Binary Comparison - (c) 2019 by noseglasses"
         ,"doc_title" : doc_title   
         ,"elf_diff_repo_base" : repo_path
         ,"old_binary_file" : fixStringForHTML(self.settings.old_alias)
         ,"new_binary_file" : fixStringForHTML(self.settings.new_alias)
         
         ,"code_size_old_overall" : str(old_binary.progmem_size)
         ,"code_size_new_overall" : str(new_binary.progmem_size)
         ,"code_size_change_overall" : memDeltaHTML(self.old_binary.progmem_size, self.new_binary.progmem_size)
         ,"static_ram_old_overall" : str(old_binary.static_ram_size)
         ,"static_ram_new_overall" : str(new_binary.static_ram_size)
         ,"static_ram_change_overall" : memDeltaHTML(self.old_binary.static_ram_size, self.new_binary.static_ram_size)
         ,"text_size_old_overall" : str(old_binary.text_size)
         ,"text_size_new_overall" : str(new_binary.text_size)
         ,"text_size_change_overall" : memDeltaHTML(old_binary.text_size, self.new_binary.text_size)
         ,"data_size_old_overall" : str(old_binary.data_size)
         ,"data_size_new_overall" : str(new_binary.data_size)
         ,"data_size_change_overall" : memDeltaHTML(self.old_binary.data_size, self.new_binary.data_size)
         ,"bss_size_old_overall" : str(old_binary.bss_size)
         ,"bss_size_new_overall" : str(new_binary.bss_size)
         ,"bss_size_change_overall" : memDeltaHTML(old_binary.bss_size, self.new_binary.bss_size)
         
         ,"total_symbols_old" : str(len(old_binary.symbols.keys()))
         ,"total_symbols_new" : str(len(new_binary.symbols.keys()))
                  
         ,"num_persisting_symbols" : str(len(self.binary_pair.common_symbol_names))
         ,"num_disappeared_symbols" : str(self.binary_pair.num_symbols_disappeared)
         ,"num_new_symbols" : str(self.binary_pair.num_symbols_new)
         ,"num_similar_symbols" : str(num_similar_symbols)
         
         ,"persisting_symbols_table" : persisting_symbols_table
         ,"disappeared_symbols_table" : disappeared_symbols_table
         ,"new_symbols_table" : new_symbols_table
         ,"similar_symbols_table" : similar_symbols_table
         
         ,"persisting_symbols_delta" : persisting_symbols_delta
         ,"disappeared_symbols_size" : disappeared_symbols_size
         ,"new_symbols_size" : new_symbols_size
         
         ,"persisting_symbol_details_html" : persisting_symbol_details_html
         ,"disappeared_symbol_details_html" : disappeared_symbol_details_html
         ,"new_symbol_details_html" : new_symbol_details_html
         ,"similar_symbol_details_html" : similar_symbol_details_html
         
         ,"old_binary_info" : fixStringForHTML(self.settings.old_binary_info)
         ,"new_binary_info" : fixStringForHTML(self.settings.new_binary_info)
         
         ,"build_info": fixStringForHTML(self.settings.build_info)
         
         ,"date" : datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
      }
      
      self.configureHTMLTemplate(html_filename, keywords)
  
   def writeTextFile(self):
      
      out = self.settings.out
      
      if self.settings.project_title:
         title = self.settings.project_title
      else:
         title = "ELF Binary Comparison"
            
      old_binary = self.binary_pair.old_binary
      new_binary = self.binary_pair.new_binary
      
      out.write("%s\n" % (title))
      out.write("   (c) 2019 by noseglasses (shinynoseglasses@gmail.com)\n")
      
      out.write("Comparing binaries\n")
      out.write("   old: %s\n" % (self.settings.old_alias))
      out.write("   new: %s\n" % (self.settings.new_alias))
      
      out.write("\n")
      
      if self.settings.build_info != "":
         out.write("Build Info:\n") 
         out.write(self.settings.build_info + "\n")
         out.write("\n")
         
      if old_binary == new_binary:
         out.write("   No symbol differences\n")
         return
      
      out.write("Binary size:\n")
      if old_binary.progmem_size == new_binary.progmem_size:
         out.write("   no changes\n")
      else:
         out.write("   " + formatMemChange("overall", old_binary.progmem_size, new_binary.progmem_size) + "\n")
         out.write("   " + formatMemChange("text", old_binary.text_size, new_binary.text_size) + "\n")
         out.write("   " + formatMemChange("data", old_binary.data_size, new_binary.data_size) + "\n")
         
      out.write("\n")
      
      out.write("Static RAM consumption:\n")
      if old_binary.static_ram_size == new_binary.static_ram_size:
         out.write("   no changes\n")
      else:
         out.write("   " + formatMemChange("overall", old_binary.static_ram_size, new_binary.static_ram_size) + "\n")
         out.write("   " + formatMemChange("data", old_binary.data_size, new_binary.data_size) + "\n")
         out.write("   " + formatMemChange("bss", old_binary.bss_size, new_binary.bss_size) + "\n")
           
      out.write("\n") 
      out.write("text: code instructions\n")
      out.write("data: initilized global or static variables\n")
      out.write("bss: uninitialized global or static variables\n")
         
      out.write("\n")
      
      out.write("%d symbols found in %s\n" % (len(old_binary.symbols.keys()), self.settings.old_alias))
      out.write("%d symbols found in %s\n" % (len(new_binary.symbols.keys()), self.settings.new_alias))
      
      out.write("\n")
      
      out.write("%d symbols persisted\n" % (len(self.binary_pair.common_symbol_names)))
      
      out.write("\n")
      
      if self.binary_pair.num_symbol_size_changes != 0:
         out.write("%d symbols changed size:\n" % (self.binary_pair.num_symbol_size_changes))
         
         for symbol_name in self.binary_pair.common_symbol_names:
            old_symbol = old_binary.symbols[symbol_name]
            new_symbol = new_binary.symbols[symbol_name]
            if old_symbol.size != new_symbol.size:
               out.write("   " + formatMemChange(symbol_name, old_symbol.size, new_symbol.size) + "\n")
         
      out.write("\n")
      
      if len(self.binary_pair.symbols_only_in_old) > 0:
         
         out.write("%d symbols dissappeared (%d bytes, see details below):" % (self.binary_pair.num_symbols_disappeared, self.binary_pair.num_bytes_disappeared) + "\n")
         
         for symbol_name in self.binary_pair.symbols_only_in_old:
            symbol = old_binary.symbols[symbol_name]
            out.write("   %s: %d bytes" % (symbol_name, symbol.size) + "\n")
               
      out.write("\n")
      
      if len(self.binary_pair.symbols_only_in_new) > 0:

         out.write("%d new symbols (%d bytes, see details below):" % (self.binary_pair.num_symbols_new, self.binary_pair.num_bytes_new) + "\n")
         
         for symbol_name in self.binary_pair.symbols_only_in_new:
            symbol = new_binary.symbols[symbol_name]
            out.write("   %s: %d bytes" % (symbol_name, symbol.size) + "\n")
               
      out.write("\n")
      
      if len(self.binary_pair.similar_symbols) > 0:

         out.write("%d similar symbol pairs:\n" % (len(self.binary_pair.similar_symbols)))
         
         for symbol_pair in self.binary_pair.similar_symbols:
            old_symbol = symbol_pair[0]
            new_symbol = symbol_pair[1]
            out.write("   %s: %d bytes" % (old_symbol.name, old_symbol.size) + "\n")
            out.write("   %s: %d bytes" % (new_symbol.name, new_symbol.size) + "\n")
            out.write("\n")
               
      out.write("\n")
      
      out.write("Binary Info:\n")
      out.write("Old:\n")
      out.write(self.settings.old_binary_info + "\n")
      out.write("New:\n")
      out.write(self.settings.new_binary_info + "\n")
      
      out.write("\n")
      
      out.write("########################################################################\n")
      out.write("Details follow\n")
      out.write("########################################################################\n")
      
      out.write("\n")
      
      out.write("The following %d symbols' assembly differs\n" % (self.binary_pair.num_assemblies_differ) + "\n")
      out.write(self.generatePersistentSymbolDetailsString())
      
      out.write("Disappeared symbols\n")
      out.write(self.generateDisappearedSymbolDetailsString())
      out.write("New symbols\n")
      out.write(self.generateNewSymbolDetailsString())
      out.write("Similar symbols\n")
      out.write(self.generateSimilarSymbolDetailsString())
      
class MultiReport(Report):
   
   def __init__(self, settings, yaml_file):
      
      self.settings = settings
      
      self.yaml_file = yaml_file
      
      self.parseYaml()
      
   def parseYaml(self):
      
      import yaml
      
      my_yaml = None
      with open(self.yaml_file, 'r') as stream:
         try:
            my_yaml = yaml.load(stream)
         except yaml.YAMLError as exc:
            print(exc)
            return
         
      # my_yaml is supposed to be list of binary pairs
      
      self.binary_pairs = []
      
      for data_set in my_yaml:
         
         old_binary_filename = data_set.get("old_binary")
         new_binary_filename = data_set.get("new_binary")
         
         bp = PairReport(self.settings, \
                         old_binary_filename, \
                         new_binary_filename)
         
         bp.title = data_set.get("title")
            
         self.binary_pairs.append(bp)
         
   def generateResourceConsumptionTableHTML(self):
      
      table_lines_html = ""
      
      for binary_pair in self.binary_pairs:
         
         code_size_old_overall = binary_pair.old_binary.progmem_size
         code_size_new_overall = binary_pair.new_binary.progmem_size
         code_size_delta_overall = memDeltaHTML(binary_pair.old_binary.progmem_size, \
                                                binary_pair.new_binary.progmem_size)
         
         static_ram_old_overall = binary_pair.old_binary.static_ram_size
         static_ram_new_overall = binary_pair.new_binary.static_ram_size
         static_ram_change_overall = memDeltaHTML(binary_pair.old_binary.static_ram_size, \
                                                  binary_pair.new_binary.static_ram_size)
         
         table_lines_html += "<tr><td>%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td><td>%s</td></tr>\n" % ( \
            title, \
            code_size_old_overall, \
            code_size_new_overall, \
            code_size_delta_overall, \
            static_ram_old_overall, \
            static_ram_new_overall, \
            static_ram_change_overall \
         )

      return table_lines_html
   
   def generateSymbolsTableHTML(self):
      
      table_lines_html = ""
      
      for binary_pair in self.binary_pairs:
      
         num_persisting_symbols =  str(len(binary_pair.common_symbol_names))
         num_disappeared_symbols = str(binary_pair.num_symbols_disappeared)
         num_new_symbols = str(binary_pair.num_symbols_new)
         
         table_lines_html += "<tr><td>%s</td><td>%s</td><td>%s</td><td>%s</td></tr>\n" % ( \
            title, \
            num_persisting_symbols, \
            num_disappeared_symbols, \
            num_new_symbols
         )
      
      return table_lines_html
   
   def writeHTMLFile(self, html_file, skip_details):
      
      resource_consumtption_table = self.generateResourceConsumptionTableHTML()
      symbols_table = self.generateSymbolsTableHTML()
      
      keywords = { \
          "page_title" : u"ELF Binary Comparison - (c) 2019 by noseglasses" \
         ,"resource_consumtption_table" : resource_consumtption_table \
         ,"symbols_table" : symbols_table \
      }
      
      self.configureHTMLTemplate(html_file, keywords)
      
   def writeTextFile(self):
      
      # TODO

class Driver(object):
   
   def __init__(self):
  
      self.settings = Settings()
      
      if settings.driver_file:
         
         bpg = MultiReport(self.settings, settings.driver_file)
         
         pb.generate()
         
      else:
         
         bp = PairReport(self.settings, \
                         self.settings.old_binary_filename, \
                         self.settings.new_binary_filename):
        
         bp.generate()
  
if __name__ == "__main__":
   driver = Driver()
